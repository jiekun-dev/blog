---
title: "基于 Canal 与 Kafka 的实时数据核对系统"
date: 2021-11-24T11:00:36+08:00
excerpt: 在构建微服务生态的过程中，随着单体服务的拆分、新业务的引入，越来越多的微服务运行在 Kubernetes 上。与单体服务不同，微服务间的数据往往需要通过额外的手段来保障一致性，例如事务消息、本地事务表、一致性补偿等。本文介绍 Shopee Credit 团队如何在不侵入现有服务的情况下构建一套旁路系统，对多个服务的数据一致性进行观测，达到实时预警的目标，为数据保驾护航。
draft: true
---

# 1. 背景
## 1.1 转型微服务的数据痛点
在**单体应用**（Monolithic Application）向**微服务**（Microservices）转型的过程中，都需要解决服务拆分后数据一致性的问题。单体应用内，很容易通过数据库事务等手段约束不同 Table 的数据，当这些 Table 被划分至各个微服务时，服务间通过 RPC 调用进行交互，缺乏原生的一致性保障，需要使用额外的方式使之达到最终的一致状态，例如本地事务表 + 异步补偿任务、事务消息中间件等。

在重要的场景下，不管使用何种一致性方案，提供额外的检查、核对、兜底手段都是必要的，由此衍生出了很多的业务核对、对账的需求。服务间通过特定手段保障一致性，并设计无侵入的旁路系统进行数据核对和校验，是微服务架构下的典型搭配。

## 1.2 现有核对方案短板
常见的数据核对通常按照一定的筛选条件，从不同数据源中获取特定数据，再进行比较，最为普遍的方案伪代码如：

```Go
func Check() {
    // Fetch rows which update_time between a and b
    upstreamRows := SelectFromUpstreamDB()

    for uniqueKey, sourceData := range upstreamRows {
        // For each row in source, select corresponding row from downstream
        targetData := FindFromDownstreamDB(uniqueKey)

        // Compare row
        Compare(sourceData, targetData)
    }
}
```

**时效性低**是这类查表方案的通病。核对操作通常放在异步任务中定时执行，定时任务的时间间隔、查询条件都会对核对目标造成影响。在没有结合业务场景、写操作的模式来精心设计这些任务参数，或是受限于特定资源的情况下，异常问题容易留到下一次任务执行甚至次日后才能被检查出来。

引入了**额外的扫表开销**同样是个不容忽视的问题。在数据量较大，尤其是存在大量 `INSERT` 操作的场景下，想要核对就需要 `SELECT` 出上下游的目标数据。为了在不影响正常业务的情况下及时处理完核对任务，开发者可能通过将查询转移到从库，甚至引入核对任务独占的从库，使得此类查表核对方案在资源使用和实现复杂度上都不够理想。

同时，由于查表得到的结果只是当前的数据版本，在两次检查之间，数据可能发生了多次变更，**定时任务无法感知和观测到每个状态变更**，在数据被频繁 `UPDATE` 的场景下也存在一定的业务风险。

因此，要实现更好的数据核对，我们考虑以下几点：
1. **实时**
2. **避免查表**
3. **核对数据变更**，而非核对数据快照

# 2. 实时数据核对
实时数据核对，顾名思义，需要研发团队实现的内容包括“实时”和“核对”。在具体设计上，核对系统划分为 **CDC（Change data capture）模块**和**核对模块**。CDC 模块代替原有的查表操作，以一定的格式将数据变更输送至核对模块。核对模块则负责复杂的核对逻辑，包括数值转换、状态映射等，判定输入的数据是否相等、是否符合预期映射。

## 2.1 CDC 方案
在数据库领域，CDC 是一种设计模式，通过跟踪数据变更来决定要执行什么样的动作。实际上，传统的扫表获取特定 `update_time` 范围的数据也可以视为 CDC 的一种实现。在本文中，我们将 CDC 方案划分为两类：
- 基于时间戳（Timestamps）或基于数据 Diff（Table Differencing）
- 基于触发器（Triggers）或日志（Log-Based）

### 2.1.1 Timestamps & Table Differencing
**Timestamps** 即前文多次提到的基于 `update_time` 字段的 CDC 方案。类似的，基于 `status`、`version` 等字段的设计也可以视为 Timestamps 方案的拓展方案。除了 1.2 小节的缺点外，Timestamps 方案无法感知数据删除，只能使用状态软删除来代替，局限性较大。

**Table Differencing** 通过拉取全量数据进行快照的比较，输出差异部分，可以弥补 Timestamps 方案感知 DELETE 操作上的缺陷。但是很显然，拉取全量数据进行比较是非常重的操作，需要耗费更多的 I/O 和 CPU 资源。

Timestamps 与 Table Differencing 划分在同一类是因为它们都有同一个缺陷：由数据变更以外的动作触发，如定时任务。这意味着此类方案都有一定的延迟，相比后续的（准）实时 CDC 方案而言，是个非常致命的短板。

### 2.2.2 Triggers & Log-Based
**Triggers** 方案依赖数据库的触发器（Trigger），通过给特定的 Table 设置 DDL、DML 语句触发器

### 2.2.3 Log-Based 实现：Canal

## 2.2 数据核对
### 2.2.1 延迟队列

## 2.3 整体架构设计

# 3. 优化
## 3.1 Runtime 表达式执行

## 3.2 性能

# 4. 总结
