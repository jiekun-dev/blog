---
title: 我的Join查询是如何得出结果的？
author: 小黄鸭
type: post
date: 2020-08-08T08:54:53+00:00
excerpt: Join查询的几种基础算法
featured_image: /wp-content/uploads/2020/08/join_algorithm.png
categories:
  - 数据库

---
# Join Algorithms

在需要连接多表数据时，我们通常会使用到`JOIN`操作。

# Nested Loop Join

## Basic Nested Loop Join

假设现在有两个关系对集合，`R`和`S`，我们需要将它连接起来，连接通过一定的条件来指定，这个条件我们称为**Join Predicate**，即连接谓词:

```
JP(r, s) := r.x == s.x</code></pre>

```
这个连接谓词表明`R`与`S`依靠字段`x`相等作为条件进行连接，当满足条件时，`JP(r, s)`返回为`True`，否则为`False`。

下面用伪代码表述**Nested Loop Join**的处理过程：

```
# R
# S
# JP(r, s) := r.x == s.x

def nested_loop_join(R, S, JP(r, s)):
    for r in R:
        for s in S:
            if JP(r, s):
                outupt((r, s))</code></pre>

```
可以看出Nested Loop Join的处理过程即是两个关系对集合`R`与`S`的求**Cross Product**过程，因此若`R`中有n个关系对，`S`中有m个关系对，他们的处理复杂度即为`O(m * n)`。

**Nested Loop Join**的优势在于它不仅可以在等值连接（EquiJoin）中使用，还可以处理其他非等值连接：

  * 在NLJ中无需关注判定式`JP(r, s)`的实现
  * 对于非等值连接，只判定式内部实现对应**Join Predicate**即可，外层循环无感知。如：`JP(r, s) := r.x <= s.x`

## Indexed Nested Loop Join

现在输入的情况稍作改变，我们不仅有`R`、`S`和连接谓词`JP(r, s)`，还知道在其中一个关系集合，无论是`R`还是`S`，的连接谓词的列`x`上有对应的索引：

```
IndexOnRX := catelog.get(indexes, R.x)</code></pre>

```
`IndexOnRX`现在可以视为一个`R`上`x`列的索引查询方法，它可以接收查询值，并且返回一个集合，代表集合中的元素存在于`R`中。

下面用伪代码表述**Indexed Nested Loop Join**的处理过程：

```
# S
# JP(r, s)
# IndexOnRX

def indexed_nested_loop_join(IndexOnRX, S, JP(r, s)):
    for s in S:
        query_result_set = IndexOnRX(s.x)
        if query_result_set != None:
            output({s} * query_result_set)</code></pre>

```
与NLJ不同，INLJ通过遍历其中1个关系对集合S，使用对应的索引查询得到另一个查询集合**R的子集**，如果有符合的case，将`{s} * query_result_set`结果追加到最后输出的集合中。因此在INLJ中，因为只遍历了其中一个关系对集合，查询复杂度可以视为`O(n)`。

# Hash Join

现在我们同样有两个关系对集合`R`和`S`，一个连接谓词`JP(r, s) := r.x == s.x`。  
下面用伪代码来表述**Simple Hash Join**的处理过程：

```
# R
# S
# JP(r, s) := r.x == s.x

def simple_hash_join(R, S, JP(r, s)):
    indexOnRX := build_ht(R.x)
    for s in S:
        query_result_set = IndexOnRS(s.x)
        if query_result_set != None:
            output({s} * query_result_set)</code></pre>

```
可以看出在循环和判定上，SHJ和INLJ非常相似，最大的区别在于SHJ使用了一个临时生成的Hash内存表作为`IndexOnRS`依据。由于使用Hash Table，因此SHJ相比之前的NLJ而言缺少了非等值查询的支持。同时在查询复杂度上，SHJ先遍历其中一个关系对集合生成HT，再遍历另一个关系对进行判定，因此为`O(m + n)`

# Sort-Merge Join

现在我们有两张表`Customer`和`City`，我们需要通过`Join`操作获取每个customer所在的city。

<table class="wp-block-table">
  <tr>
    <th>
      name
    </th>
    
    <th>
      street
    </th>
    
    <th>
      cityID
    </th>
    
    <th>
    </th>
    
    <th>
    </th>
    
    <th>
    </th>
    
    <th>
      cityID
    </th>
    
    <th>
      city
    </th>
  </tr>
  
  <tr>
    <td>
      n1
    </td>
    
    <td>
      s1
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      A
    </td>
  </tr>
  
  <tr>
    <td>
      n2
    </td>
    
    <td>
      s2
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      1
    </td>
    
    <td>
      B
    </td>
  </tr>
  
  <tr>
    <td>
      n3
    </td>
    
    <td>
      s3
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      3
    </td>
    
    <td>
      C
    </td>
  </tr>
  
  <tr>
    <td>
      n4
    </td>
    
    <td>
      s4
    </td>
    
    <td>
      1
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      5
    </td>
    
    <td>
      D
    </td>
  </tr>
  
  <tr>
    <td>
      n5
    </td>
    
    <td>
      s5
    </td>
    
    <td>
      1
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      7
    </td>
    
    <td>
      E
    </td>
  </tr>
  
  <tr>
    <td>
      n6
    </td>
    
    <td>
      s6
    </td>
    
    <td>
      5
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      9
    </td>
    
    <td>
      F
    </td>
  </tr>
  
  <tr>
    <td>
      n7
    </td>
    
    <td>
      s7
    </td>
    
    <td>
      5
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
  </tr>
  
  <tr>
    <td>
      n8
    </td>
    
    <td>
      s8
    </td>
    
    <td>
      7
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
  </tr>
  
  <tr>
    <td>
      n9
    </td>
    
    <td>
      s9
    </td>
    
    <td>
      9
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
  </tr>
  
  <tr>
    <td>
      n10
    </td>
    
    <td>
      s10
    </td>
    
    <td>
      9
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
  </tr>
  
  <tr>
    <td>
      n11
    </td>
    
    <td>
      s11
    </td>
    
    <td>
      9
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
  </tr>
</table>

我们按照以下原则进行**Merge Join**：

  * 使用两个指针，分别指向两表的`cityID`字段
  * 当指针对应的值相等时，output一行结果
  * 指针需要移动至下一行时，优先移动当前指向值较小的指针，若值相等时优先移动指向`Customer`表的指针

输出结果为：

<table class="wp-block-table">
  <tr>
    <th>
      name
    </th>
    
    <th>
      street
    </th>
    
    <th>
      cityID
    </th>
    
    <th>
      city
    </th>
  </tr>
  
  <tr>
    <td>
      n1
    </td>
    
    <td>
      s1
    </td>
    
    <td>
    </td>
    
    <td>
      A
    </td>
  </tr>
  
  <tr>
    <td>
      n2
    </td>
    
    <td>
      s2
    </td>
    
    <td>
    </td>
    
    <td>
      A
    </td>
  </tr>
  
  <tr>
    <td>
      n3
    </td>
    
    <td>
      s3
    </td>
    
    <td>
    </td>
    
    <td>
      A
    </td>
  </tr>
  
  <tr>
    <td>
      n4
    </td>
    
    <td>
      s4
    </td>
    
    <td>
      1
    </td>
    
    <td>
      B
    </td>
  </tr>
  
  <tr>
    <td>
      n5
    </td>
    
    <td>
      s5
    </td>
    
    <td>
      1
    </td>
    
    <td>
      B
    </td>
  </tr>
  
  <tr>
    <td>
      n6
    </td>
    
    <td>
      s6
    </td>
    
    <td>
      5
    </td>
    
    <td>
      D
    </td>
  </tr>
  
  <tr>
    <td>
      n7
    </td>
    
    <td>
      s7
    </td>
    
    <td>
      5
    </td>
    
    <td>
      D
    </td>
  </tr>
  
  <tr>
    <td>
      n8
    </td>
    
    <td>
      s8
    </td>
    
    <td>
      7
    </td>
    
    <td>
      E
    </td>
  </tr>
  
  <tr>
    <td>
      n9
    </td>
    
    <td>
      s9
    </td>
    
    <td>
      9
    </td>
    
    <td>
      F
    </td>
  </tr>
  
  <tr>
    <td>
      n10
    </td>
    
    <td>
      s10
    </td>
    
    <td>
      9
    </td>
    
    <td>
      F
    </td>
  </tr>
  
  <tr>
    <td>
      n11
    </td>
    
    <td>
      s11
    </td>
    
    <td>
      9
    </td>
    
    <td>
      F
    </td>
  </tr>
</table>

注意到这种Merge操作的前提是两表的连接谓词所在字段必须是排序的，因此这种连接算法称为**Sort-Merge Join**。

根据以上条件写出伪代码：

```
# R
# S
# JP(r, s)

def sort_merge_join(R, S, JP(r, s)):
    sort(R on R.x)
    sort(S on S.x)
    pointer_r = R[0]
    pointer_s = S[0]

    while pointer_r != R.end and pointer_s != S.end:
        if pointer_r.x == pointer_s.x:
            output((pointer_r, pointer_s))

        if pointer_r.x &lt;= pointer_s.x:
            pointer_r++
        else:
            pointer_s++

    # handle rest row here</code></pre>

```
要注意如果将`Customer`表与`City`表位置互换，并且保持优先移动左表(`City`)表指针，我们输出的结果将会是不正确的。

另外，如果两表的排序字段都不是主键或唯一，输出的结果也会有遗漏的case。

因此，**Sort-Merge Join**算法有必须满足的前提条件：

  * Join字段在其中一个表中必须唯一
  * 保持优先移动ref表（即Join字段非唯一的表）

最后估算查询复杂度，需要先进行排序，为`O(nlogn)`的复杂度，然后双指针遍历两表为`O(m+n)`的复杂度。

# Conclusion

Join操作使用的基础算法：

  * Nested Loop Join，可以视为两表相乘，嵌套循环逐行检查是否满足Join条件
  * Indexed Nested Loop Join，遍历部分表，并用遍历结果作为索引查询条件，借助索引查询
  * Hash Join，可以视为INLJ的特殊情况，区别在于Hash Join使用现有或临时生成的Hash值作为索引，此时不支持非等值连接
  * Sort-Merge Join，限定条件比较多，先根据Join字段排序，再合并两表，同样不支持非等值连接，否则会退化为NLJ