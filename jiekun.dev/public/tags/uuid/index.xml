<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>UUID on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/uuid/</link>
    <description>Recent content in UUID on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 28 Dec 2019 10:23:47 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/uuid/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[翻译] UUID方案很受欢迎，但是于性能不利</title>
      <link>https://jiekun.dev/posts/2019-12-28-%E7%BF%BB%E8%AF%91-uuid%E6%96%B9%E6%A1%88%E5%BE%88%E5%8F%97%E6%AC%A2%E8%BF%8E%E4%BD%86%E6%98%AF%E4%BA%8E%E6%80%A7%E8%83%BD%E4%B8%8D%E5%88%A9/</link>
      <pubDate>Sat, 28 Dec 2019 10:23:47 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-12-28-%E7%BF%BB%E8%AF%91-uuid%E6%96%B9%E6%A1%88%E5%BE%88%E5%8F%97%E6%AC%A2%E8%BF%8E%E4%BD%86%E6%98%AF%E4%BA%8E%E6%80%A7%E8%83%BD%E4%B8%8D%E5%88%A9/</guid>
      <description>在网上搜索UUID方案和MySQL，你能查到一大堆结果，比如：
 存储UUID和Generated Columns 在MySQL中存储UUID值 InnoDB中的主键模型及它们对磁盘使用的影响 MySQL UUID Smackdown: UUID与整型的主键对比 GUID/UUID性能突破 用还是不用UUID？  所以对于资料如此完善的话题还需要更多讨论吗？很明显是要的。尽管很多文章都是提醒人们少用UUID方案，但它们还是很受欢迎。受欢迎的原因是UUID值可以很方便地由远程设备生成，并且冲突概率非常低。这篇文章里我的目标是总结其他人写的内容，并且尽可能提出一些新的观点。
什么是UUID方案？ UUID即全局唯一标识符（Universally Unique IDentifier），在RFC 4122定义。它的格式是128位，16进制，由“-”分割成5部分。典型的UUID值如下：
yves@laptop:~$ uuidgen 83fda883-86d9-4913-9729-91f20973fa52&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 官方来说，一共有5类UUID值，版本1-5,但最常见的是：基于时间的版本（版本1或版本2）和纯随机的版本（版本3）。基于时间的UUID方案将1970年1月1日以来的10ns数量编码成7.5字节（60位），分割为“time-low”-“time-mid”-“time-hi”的样式。空缺的4位是用在time-hi段作为prefix。这样前三段的64位就定下来了。后两段是时间序列即一个随时间改动而增加的值，和宿主唯一标识符（host unique identifier）。大多数时候，当前宿主网络的MAC地址都会被用来当作唯一标识符。
在使用基于时间的UUID时，有几个重要的点需要考虑：
 在前三段的值生成后，就可以用来确认大致的时间 在连续的UUID值中会有大量重复的段 第一段“time-low”每过429秒就会耗尽重置 MySQL UUID函数产生的是版本1的值  以下是使用“uuidgen”Unix工具产生的基于时间的UUID值：
yves@laptop:~$ for i in $(seq 1 500); do echo &amp;quot;$(date +%s): $(uuidgen -t)&amp;quot;; sleep 1; done 1573656803: 572e4122-0625-11ea-9f44-8c16456798f1 1573656804: 57c8019a-0625-11ea-9f44-8c16456798f1 1573656805: 586202b8-0625-11ea-9f44-8c16456798f1 ... 1573657085: ff86e090-0625-11ea-9f44-8c16456798f1 1573657086: 0020a216-0626-11ea-9f44-8c16456798f1 ... 1573657232: 56b943b2-0626-11ea-9f44-8c16456798f1 1573657233: 57534782-0626-11ea-9f44-8c16456798f1 1573657234: 57ed593a-0626-11ea-9f44-8c16456798f1 ...&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 第一段的值（在t=1573657086）重置，第二段值会增加。每过大约429秒就会在第一段看到类似的值。第三段值每年变1次。最后一段值在同一台的宿主机上是固定的，就是我的笔记本上的MAC地址：</description>
    </item>
    
  </channel>
</rss>