<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>有序集合 on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/</link>
    <description>Recent content in 有序集合 on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 31 Aug 2019 04:49:01 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Redis有序集合的实现&amp;跳跃表源码学习</title>
      <link>https://jiekun.dev/posts/2019-08-31-redis%E4%B8%ADzset%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 31 Aug 2019 04:49:01 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-08-31-redis%E4%B8%ADzset%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81%E7%9A%84%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</guid>
      <description>O(1)的skiplist成员查找？ 众所周知Redis中每种基本类型都有2种或以上的底层实现，一般谈到ZSET，我们会说它的实现是基于ziplist和skiplist的，这没有问题：
 当ZSET长度小于设定值（zset-max-ziplist-entries）或成员的长度小于设定值（zset-max-ziplist-value）时会使用ziplist的实现，否则使用skiplist实现  但是当ZSET在使用skiplist实现的时候，它对成员的查找也是O(1)复杂度。根据skiplist的结构，要查找某一个成员必须对各个SkiplistNode进行遍历，因此复杂度为O(n)。所以在ZSET-skiplist的实现中查找成员并不是根据skiplist进行的，而是使用字典（dict）。
先来看一下ZSET的结构源码，Redis5.0.5版本中数据结构的定义在redis/src/server.h中：
typedef struct zset { dict *dict; zskiplist *zsl; } zset;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 可以看到一个ZSET结构使用了一个dict和一个zskiplist（特殊版本的skiplist），具体代码在SkipList小节中再叙述。ZSET的结构可以由下图来标识：
通过这样的结构，当ZSET需要进行成员查询的时候，可以根据dict查询，时间复杂度为O(1)；当ZSET需要进行范围查找的时候，根据skiplist结构可以实现平均O(logn)复杂度的查找。
这两种结构单独使用来实现ZSET是可行的，但是dict在范围型操作的时候需要对字典保存的所有元素进行排序因此需要至少O(nlogn)的时间复杂度和额外O(n)的空间复杂度；在单独使用skiplist根据成员查找分值的时候就由O(1)时间复杂度上升到了O(logn)复杂度。因此Redis中选择同时使用dict和skiplist来实现ZSET类型。
SkipList的实现 下面来具体聊一下SkipList数据结构。
在Redis源码中找到跳跃表的相关定义，就在zset的上面几行，补充一些注释：
/* ZSETs use a specialized version of Skiplists */ # 跳跃表节点（ZSET版） typedef struct zskiplistNode { # 使用sds来存储成员名字 sds ele; # 浮点型分数 double score; # 每个zskiplist节点都带有向前的指针 struct zskiplistNode *backward; # zskiplist分层，每层中包含指向其他zskiplist节点的指针 struct zskiplistLevel { # zskiplist节点指针 struct zskiplistNode *forward; # 本层指向的下个节点离本节点的跨度 unsigned long span; } level[]; } zskiplistNode; # 跳跃表 typedef struct zskiplist { # 分别指向头尾的指针 struct zskiplistNode *header, *tail; # 长度 即跳跃表中包含的节点数目（头节点不算） unsigned long length; # 层数 即跳跃表中各节点层数的最大值（头节点不算） int level; } zskiplist;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; t的结构可以由下图来表示：</description>
    </item>
    
  </channel>
</rss>