<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>B-Tree on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/b-tree/</link>
    <description>Recent content in B-Tree on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 05 Aug 2020 12:58:10 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/b-tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>InnoDB中的B树与分裂</title>
      <link>https://jiekun.dev/posts/2020-08-05-innodb%E4%B8%AD%E7%9A%84b%E6%A0%91%E4%B8%8E%E5%88%86%E8%A3%82/</link>
      <pubDate>Wed, 05 Aug 2020 12:58:10 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2020-08-05-innodb%E4%B8%AD%E7%9A%84b%E6%A0%91%E4%B8%8E%E5%88%86%E8%A3%82/</guid>
      <description>Tree Binary Search Tree 在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。
6 / \ 3 7 / \ \ 2 5 8&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 利用这棵二叉树对各个节点进行查找，平均查找次数为(1+2+3+3+2+3) / 6 = 2.3次，比起[2，3，5，6，7，8]顺序查找次数(1+2+3+4+5+6) / 6 = 3.3次要少。
二叉查找树还可以这样构建：
2 \ 3 \ 5 \ 6 \ 7 \ 8&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 这时查找的平均次数退化为顺序查找次数。
因此如果想高性能地构造一棵二叉查找树，需要这棵二叉查找树是平衡的。
Balance Tree 平衡二叉树符合二叉查找树的定义，并且满足任何节点的两个子树高度最大差为1。
6 6 / \ / \ 3 7 3 8 / \ \ / \ / \ 2 5 8 2 5 7 9 \ 9&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 在插入新节点后，平衡二叉树节点7的左右子树高度差为2，需要通过一次左旋操作来让树重新保持平衡。
但是有的情况可能需要旋转多次才能达到平衡。</description>
    </item>
    
  </channel>
</rss>