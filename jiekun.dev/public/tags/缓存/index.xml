<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>缓存 on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/%E7%BC%93%E5%AD%98/</link>
    <description>Recent content in 缓存 on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 08 Sep 2019 05:27:22 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/%E7%BC%93%E5%AD%98/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于Redis的缓存装饰器及缓存预热设计</title>
      <link>https://jiekun.dev/posts/2019-09-08-%E5%9F%BA%E4%BA%8Eredis%E7%9A%84python%E7%BC%93%E5%AD%98%E8%A3%85%E9%A5%B0%E5%99%A8%E5%8F%8A%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sun, 08 Sep 2019 05:27:22 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-09-08-%E5%9F%BA%E4%BA%8Eredis%E7%9A%84python%E7%BC%93%E5%AD%98%E8%A3%85%E9%A5%B0%E5%99%A8%E5%8F%8A%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E8%AE%BE%E8%AE%A1/</guid>
      <description>业务背景 业务上使用的是类似MVC的架构，具体而言通过view层控制接口，logic层控制业务逻辑，models模型映射数据库。在logic层，使用了Redis缓存装饰器对满足参数要求的方法执行结果进行缓存，降低复杂逻辑页面、数据量大页面的请求执行耗时。
对于这种使用场景，当缓存失效时，因为缓存使用的位置都是复杂逻辑，再次生成缓存需要数据库层面执行，如果这一步是由用户触发（也就是cache失效后第一位用户请求的时候生成缓存），那对这位用户来说请求时间就会很长甚至504超时。因此，有必要设计缓存的自动预热以及手动预热，前者是为了避免由用户触发生成缓存的长时间等待，后者是为了特殊时候（如数据更新后，缓存还没到期）手动更新缓存。
原有的缓存装饰器 f redis_cache(ttl=None, cache_name=None, **kwargs): &amp;quot;&amp;quot;&amp;quot; Redis缓存装饰器 用于Logics层函数执行结果缓存 全局配置: config/localsettings.py REDIS_ON = True 使用示例和说明： @redis_cache(ttl=3600, cache_name=&amp;quot;&amp;quot;, arg1=1, arg2=20) def sample_method(arg1, arg2, arg3, arg4, arg5) ttl: 缓存失效3600秒 cache_name: 函数功能名 kwargs：参数中对应满足kwargs时进行缓存，示例中当函数参数包含args=1，args2=20时缓存 缓存规则：logic_cache:function_name:参数作为键名进行缓存，示例： logic_cache:sample_method:arg1:1:arg2:20:arg3:rank:arg4:people:arg5:food :param ttl: 过期时间 :param cache_name: 函数功能名 用于清理缓存时显示 方便非技术同时使用 :param kwargs: 命中何种参数时进行缓存 示例 **{&#39;arg1&#39;: 1, &#39;arg2&#39;: 20} :return: 返回函数执行结果 / 缓存结果 &amp;quot;&amp;quot;&amp;quot; def decorator(func): cache_serv = cache @wraps(func) def returned_wrapper(*args, **innerkwargs): try: func_name = func.func_name default_kwargs = kwargs is_cache_target = cache_target_judger(default_kwargs, innerkwargs) # Cache Target if REDIS_ON and is_cache_target: colon = &#39;:&#39; redis_key_prefix_list = [&#39;logic_cache&#39;, func_name] for each in innerkwargs: redis_key_prefix_list.</description>
    </item>
    
  </channel>
</rss>