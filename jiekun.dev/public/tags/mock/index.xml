<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mock on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/mock/</link>
    <description>Recent content in Mock on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 03 Aug 2019 02:46:19 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/mock/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>实现Django Models的数据mock</title>
      <link>https://jiekun.dev/posts/2019-08-03-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%A5%97%E5%AF%B9django-models%E6%95%B0%E6%8D%AEqueryset%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E7%9A%84mock%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sat, 03 Aug 2019 02:46:19 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-08-03-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%A5%97%E5%AF%B9django-models%E6%95%B0%E6%8D%AEqueryset%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E7%9A%84mock%E6%96%B9%E6%A1%88/</guid>
      <description>问题 在开发过程中，整个数据流向为：
爬虫抓取数据-&amp;gt;数据中端进行数据清洗-&amp;gt;入库Web端定义的业务表&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; 由于整个流程比较长，而且由于爬虫开发的不稳定性以及数据统计的复杂度，完整的开发往往不能完全异步进行，因为最后面向业务的Web端需要等待清洗入库的数据进行测试。
一般来说，如果Web端需要的业务数据比较简单，开发自测的时候都可以手动生成INSERT等SQL模拟假数据，但是如果业务复杂的时候，往往需要十余个Table联动的数据，手动INSERT比较麻烦，开发效率低。
思考 模拟数据的难处主要有：
 涉及地方多，如10多个表逐一写入对应数据 表与表之间的对应关系，如测试的时候需要从表1取10条数据，从表2取这10条数据对应的一周内各日的数据一共10 * 7条 编写测试SQL费事效率低，缺少开箱即用的数据生成器  为此需要有一款工具：
 根据Django的models字段随机生成数据 支持指定数据内容，如指定数据的id，方便联表查询的时候能够正确JOIN出结果 支持filter、get等常用方法，支持聚合查询 无需写入数据库，返回QuerySet 方便开关，Mock与测试真正数据之间任意切换  实现 将以上问题逐一分析：
随机生成对应类型数据 Django的Models常用的数据类型有：
CharField、IntegerField、DateTimeField、TextField、DecimalField、DateField
其余类型在开发中不常用，因此先实现这几种类型的随机生成器
CharField CharField对应Varchar和Char类型，目标是在有提供选项的时候随机返回选项中的内容，没提供选项的时候随机出0-max_length范围内的字符串，因此采用英文字母进行随机即可。
import string from random import choice, randint def charfield_generator(min_length=0, max_length=20, choices=[]): if not choices: return &#39;&#39;.join(choice(string.ascii_letters) for i in range(randint(min_length, max_length))) else: return choice(choices)&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; IntegerField IntegerField可以对应各类整数类型，包括SmallInt、TinyInt等均可共用同一个生成器通过限制长度来控制返回值。
f integerfield_generator(min_value, max_value, choices=[]): if not choices: return randint(min_value, max_value) else: return choice(choices)&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; TextField TextField在要求不严格的情况下也可以和CharField共用生成器。业务上一般超长的内容会使用TextField，如文章正文。</description>
    </item>
    
  </channel>
</rss>