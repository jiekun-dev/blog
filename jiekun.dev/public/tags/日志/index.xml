<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>日志 on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/%E6%97%A5%E5%BF%97/</link>
    <description>Recent content in 日志 on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 15 Dec 2019 13:40:15 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/%E6%97%A5%E5%BF%97/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>InnoDB——架构、日志、表和索引</title>
      <link>https://jiekun.dev/posts/2019-12-15-innodb-%E6%9E%B6%E6%9E%84%E6%97%A5%E5%BF%97%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sun, 15 Dec 2019 13:40:15 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-12-15-innodb-%E6%9E%B6%E6%9E%84%E6%97%A5%E5%BF%97%E8%A1%A8%E5%92%8C%E7%B4%A2%E5%BC%95/</guid>
      <description>前言 写这篇博文是为了将自己学习完InnoDB的内容梳理一遍。InnoDB是个很复杂很庞大的存储引擎，其中的细节显然是不可能通过一篇文章或者笔记完整地描述出来的，所以这里主要目的是“补漏”，也就是将以前学习MySQL没有了解到的InnoDB“专属”的内容进行梳理和记录。
学习的主要来源是姜承尧老师的《MySQL技术内幕——InnoDB存储引擎》一书，国内除了这本书以外，也鲜有对InnoDB进行详细介绍的书籍。应用固然重要，但是正确理解技术本身才能够从根本上解决问题。最近这段时间看的技术向的书不少，其中不乏一些夸夸其谈，滥竽充数的书，尤其在架构设计书中最为明显，部分作者直接使用官方文档的图文翻译来填充内容，如果没有个人观点和核心的代码剖析，这些书就是IT书架上的混子。当然，从姜老师这本书可以读得出来，代码、配图和很多细节的描述都是出自一个有多年技术积累的专家之手，在现在大量浑水摸鱼的IT图书市场上就显得特别的宝贵。
有几句话姜老师在前言中提及到，我认为特别重要：
 不要相信任何的“神话”，学会自己思考 不要墨守成规，大部分人都知道的事情可能是错误的 不要相信网上的传言，去测试，根据自己的实践做出决定 花时间充分地思考，敢于提出质疑  这些都是作为开发者特别需要做到的，所以花时间充分地思考，是我在这篇博客最想做到的事情，希望能够通过思考真正掌握书中的内容。
InnoDB架构模型 内存池：
 维护所有进程/线程需要访问的多个内部数据结构 缓存磁盘上的数据，方便快速读取，同时在对磁盘文件的数据修改之前在这里缓存 redo log缓冲  后台线程：
 负责刷新内存池中的数据，保证缓冲池中的内存缓存是最近的数据 将修改的数据文件刷到磁盘文件 保证发生异常的情况下InnoDB能够恢复到正常运行状态  内存 缓冲池 设置原因：CPU与磁盘速度之间的鸿沟。
在数据库中读取页的操作，先从磁盘读取到缓冲池中，读取相同页的时候判断是否在缓冲池中直接命中。
缓冲池中缓存的数据页类型有：
 索引页 数据页 undo页 insert buffer 自适应哈希索引 引擎的锁信息 数据字典信息  缓冲池允许有多个，通过参数配置，默认为1。
LRU List、Free List、Flush List 最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。
InnoDB中设置了midpoint位置，读取到新的页，虽然是“Recently Used”，但是先插入到midpoint位置而不是前端，默认配置下处于LRU列表长度的5/8处，midpoint前的列表称为new列表，midpoint后的列表称为old列表。使用midpoint优化的原因是在读取页的时候，因为会导致尾端的页被刷出LRU列表，如果直接在前端插入大量的页（一般为索引或扫描操作）会将LRU列表大量页刷出，而这部分插入的操作可能仅是一次性的，因此需要先将这些页放在midpoint位置，然后后续如果确实频繁使用再加入LRU列表的热端。
Free列表表示可用的页，如果Free列表有可用的空闲页，就会将页从Free列表中删除、加入LRU列表中；如果没有，则要从LRU列表尾端淘汰，将内存分配给新的页。可以理解成LRU长度增加，Free长度就减少，Free没有的时候还需要插页面就需要从LRU淘汰。
在LRU列表中的页被修改后，称为dirty page，缓冲区与磁盘中的数据不一致，这时候通过CHECKPOINT机制刷回磁盘，Flush列表中的页即为脏页列表，脏页既存在于LRU列表中也存在与Flush列表中，前者保证页的可用性，后者管理页刷回磁盘。
Checkpoint Checkpoint是为了解决：
 缩短数据库的恢复时间，宕机后不需要重做所有日志，而是从Checkpoint开始 缓冲池不够用时，溢出尾端页，若为脏页，将脏页刷新回磁盘 redo log不需要时，会被覆盖重用；需要使用就会强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置  InnoDB使用LSN（Log Sequence Number）来标记版本，Checkpoint也有LSN。
Checkpint有两种：
 Sharp Checkpoint，发生在数据库关闭时将所有脏页数据刷新回磁盘 Fuzzy Checkpoint，刷新部分脏页回磁盘  Fuzzy Checkpoint发生在：</description>
    </item>
    
  </channel>
</rss>