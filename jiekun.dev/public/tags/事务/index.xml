<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>事务 on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/%E4%BA%8B%E5%8A%A1/</link>
    <description>Recent content in 事务 on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 16 Dec 2019 13:17:56 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/%E4%BA%8B%E5%8A%A1/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>InnoDB——锁、事务和复制</title>
      <link>https://jiekun.dev/posts/2019-12-16-innodb-%E9%94%81%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 16 Dec 2019 13:17:56 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-12-16-innodb-%E9%94%81%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%A4%8D%E5%88%B6/</guid>
      <description>锁 数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。
InnoDB存储引擎中的锁  共享锁（S Lock），允许事务读一行数据 排他锁（X Lock），允许事务删除或更新一行数据  兼容性：
 S与S可以兼容 X不与任何锁兼容  InnoDB支持多粒度锁定，也就是允许行级和表级的锁同时存在。实现方式为通过意向锁（Intention Lock）：如果需要对最细粒度进行加锁，需要在上层粒度加意向锁。
具体举例，如果需要对行加X锁，需要对表、页依次加IX锁。当意向锁遇到等待时，必须等待结束后才能继续对下级加锁。如准备加对一行有S锁的行加S锁，行记录因为原来就有S锁，所以表和页都已经存在了IS锁，首先新的IS锁加在表上，因为IS、IS锁兼容，可以加上；然后再看页锁，同样IS、IS兼容，可以加上；最后看行锁IS与S兼容，那么行记录可以加上S锁。对同样这行有S锁的行加X锁，先加表IX锁，IX与IS兼容，可以加上，页同样，最后IX锁与行记录上的S锁不兼容，因此要等待S锁释放后才能加上X锁。
一致性非锁定读 一致性非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过行多版本控制（multi version）的方式来读取当前执行时间数据库中行的数据。在行记录正在执行DELETE或UPDATE时执行读操作，不会等待锁释放，而是会去读undo段中的行的快照数据。
在不同的事务隔离级别下，读取方式不同，不是每个事务隔离级别都采用非锁定的一致性读，即使使用CNR，对快照数据的定义也不一样。快照数据就是undo段中的历史版本，一行记录可能有多个版本，一般称为行多版本技术，由此带来的并发控制，称之为多版本并发控制（Multi Version Concurrency Control，MVCC）。
在事务隔离级别READ COMMITTED下，非一致性读总是读取被锁定行的最新一份快照数据，而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。
表中所示的事务执行过程，在READ COMMITED中会话A可以SELECT到0个id=1的结果，因为已经被会话B所更新；而在REPEATABLE READ中因为读取的是事务开始前的快照，因此结果不会发生变化（可重复读）。
一致性锁定读 REPEATABLE READ隔离级别下，InnoDB的SELECT操作使用一致性非锁定读，但支持两种一致性锁定读操作：
 SELECT…FOR UPDATE (X Lock) SELECT…LOCK IN SHARE MODE (S Lock)  锁的算法 InnoDB存储引擎有3种行锁的算法：
 Record Lock：单个行记录上的锁 Gap Lock：间隙锁，锁定一个范围，但不包括记录本身 Next-Key Lock：Gap Lock+Record Lock，锁定一个范围和记录本身  InnoDB对于行的查询都是采用Next-Key Lock，例如索引有10，11，13，和20，那么可锁定的区间有：
 (-∞, 10] (10, 11] (11, 13] (13, 20] (20, +∞)  Next-Key Lock的设计是为了解决Phantom Problem。除了Next-Key Lock还有Previous-Key Lock，区别在于区间的开闭。</description>
    </item>
    
  </channel>
</rss>