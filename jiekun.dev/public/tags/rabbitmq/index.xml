<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RabbitMQ on Jiekun&#39;s Blog</title>
    <link>https://jiekun.dev/tags/rabbitmq/</link>
    <description>Recent content in RabbitMQ on Jiekun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 26 Sep 2019 14:09:28 +0000</lastBuildDate>
    
	<atom:link href="https://jiekun.dev/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>理解AMQP协议和RabbitMQ的性能和可靠平衡</title>
      <link>https://jiekun.dev/posts/2019-09-26-%E7%90%86%E8%A7%A3amqp%E5%8D%8F%E8%AE%AE%E5%92%8Crabbitmq%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E9%9D%A0%E5%B9%B3%E8%A1%A1/</link>
      <pubDate>Thu, 26 Sep 2019 14:09:28 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-09-26-%E7%90%86%E8%A7%A3amqp%E5%8D%8F%E8%AE%AE%E5%92%8Crabbitmq%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E9%9D%A0%E5%B9%B3%E8%A1%A1/</guid>
      <description>前言 在之前的博客中，已经使用Pika包实践操作过RabbitMQ了，借用了几个不同的Exchange实现不同功能的生产-消费模式，但是对RabbitMQ的细节还缺乏更进一步的理解。今天从AMQP协议起更仔细地来看一下MQ背后的实现。
AMQP协议 RabbitMQ通过AMQP协议通信，这就类似于HTTP客户端和服务器进行通信一样。
在AMQP中，客户端和服务器之间的通信数据是拆成帧（frame）的结构。
对话启动 需要对话首先要建立连接：
客户端先发送协议头（protocol header）给服务器，服务器收到后，返回Connection.Start给客户端，客户端确认后返回Connection.StartOk给服务器，完成回话启动。
信道 AMQP规范定义了通信的信道，一个AMQP连接可以有多个信道，允许客户端和服务器之间进行多次会话。
AMQP帧结构 上面留意到，建立连接时服务器和客户端的相应都有共同部分Connection，因为AMQP命令是分为类和方法，用点（.）连接。连接时，Connection是使用的类，Start和StartOk是方法。
AMQB的帧由以下组件组成：
 帧类型 信道 帧大小（字节） 帧有效载荷 结束字节标记（0xce）  AMQP的帧有五种类型：
 协议头帧，也就是上面建立连接使用，仅使用一次 方法帧，携带发送或接收的请求或相应 内容头帧，消息的大小和属性 消息体帧，消息的内容 心跳帧，双向均可发送，确保连接两端可用和正常工作  下面来看一下这几种类型的帧如何组成消息。
 除了建立连接以外，AMQP在通信时，首先使用方法帧构建RPC请求所需的类、方法和参数。按照上文的帧结构，现在构造一个帧：  帧类型为方法帧（1） 信道0 有效载荷大小为41 有效载荷为类、方法、参数等   以0xce结尾   方法帧通知对方后，继续构造一个内容头帧，告知对方接下来要发送的消息大小和属性：  帧类型为内容头帧（2） 信道1 有效载荷大小为45 有效载荷为：消息体大小55，被设置的属性为144（内容类型）和200（app_id），被设置的属性的值分别为application/json和Test，timestamp属性为1014206880，投递模式为1   以0xce结尾  注意内容头帧声明的这些属性是在BasicProperty映射表中的。
 内容头帧通知对方后，继续构造一个消息体帧发送具体消息：  帧类型为消息体帧（3） 信道为1 有效载荷大小为55（对应内容头帧中的55） 有效载荷为一段JSON格式的字符串   以0xce结尾  注意AMQP协议是不会理会消息中的内容的，不对消息进行解析，即使知道对方是JSON格式内容。
使用AMQP协议 了解完AMQP协议的格式后，来看一下如何使用AMQP协议。
首先，需要声明一个交换器（Exchange）。交换器在AMQP规范中有自己的类，使用Exchange.Declear命令创建交换器，服务端使用Exchange.DeclearOk进行响应：
然后再创建一个队列（Queue）。同样Queue.Declear和Queue.DeclearOk完成。注意声明队列的时候多次发送同一个Queue.Declear不会有作用，只有第一次Declear会被处理，后续再Declear同样内容无效，Declear同名不同属性队列也无效。
现在我们有交换器和队列，在之前的博客中我们知道，消息是发送给Exchange的，然后Exchange推送至队列中。Exchange和Queue的关系需要进行绑定。使用Queue.Bind和Queue.BindOk命令将Queue绑定至Exchange。</description>
    </item>
    
    <item>
      <title>RabbitMQ入门学习笔记</title>
      <link>https://jiekun.dev/posts/2019-08-18-rabbitmq%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 18 Aug 2019 04:35:28 +0000</pubDate>
      
      <guid>https://jiekun.dev/posts/2019-08-18-rabbitmq%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>RabbitMQ简介 RabbitMQ是个消息中间件。
 Producer：发送消息的程序称为生产者 Queue：消息在RabbitMQ中存储在队列，队列上限由内存和磁盘决定。队列本质上讲就是一个大的消息缓冲区，多个生产者可以发消息到同一个队列，多个消费者可以从同一个队列获取消息。 Consumer：等待接受消息的程序称为消费者  本文目标：
 了解RabbitMQ基础模型 了解RabbitMQ不同的Exchange类型  Hello World 官方教程使用Pika作为RabbitMQ的Python客户端。
send.py:
import pika # 连接本地RabbitMQ connection = pika.BlockingConnection( pika.ConnectionParameters(host=&#39;localhost&#39;)) channel = connection.channel() # 声明要将消息发送至的队列 channel.queue_declare(queue=&#39;hello&#39;) # 指定exchanger, routing_key 发送消息 channel.basic_publish(exchange=&#39;&#39;, routing_key=&#39;hello&#39;, body=&#39;Hello World!&#39;) print(&amp;quot; [x] Sent &#39;Hello World!&#39;&amp;quot;) nnection.close()&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt; receive.py
#!/usr/bin/env python import pika connection = pika.BlockingConnection( pika.ConnectionParameters(host=&#39;localhost&#39;)) channel = connection.channel() # 同样声明队列 channel.queue_declare(queue=&#39;hello&#39;) # 接收到消息时执行 def callback(ch, method, properties, body): print(&amp;quot; [x] Received %r&amp;quot; % body) channel.</description>
    </item>
    
  </channel>
</rss>